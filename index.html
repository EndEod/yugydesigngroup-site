<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ì…€í”„ì¸í…Œë¦¬ì–´ ë„ë©´ë§Œë“¤ê¸°</title>

  <!-- 2D/ì…ë©´ ìº¡ì²˜ìš© -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    :root{
      --bg:#f2f2f2;
      --panel:#ffffff;
      --ink:#222;
      --muted:#666;
      --line:#e7e7e7;
      --btn:#1f2937;
      --btn2:#2563eb;
      --danger:#dc2626;
      --ok:#16a34a;
      --radius:14px;
    }
    body{ margin:0; overflow:hidden; font-family:"Segoe UI","Malgun Gothic",system-ui,sans-serif; background:var(--bg); color:var(--ink); }
    button{ font:inherit; cursor:pointer; }
    a{ color:inherit; }

    /* âœ… ì™¼ìª½ íŒ¨ë„ */
    #ui{
      position:fixed; left:12px; top:12px; z-index:1000;
      width:360px; max-height:92vh; overflow:auto;
      background:rgba(255,255,255,.97);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:0 10px 30px rgba(0,0,0,.12);
      padding:12px;

      transition: transform 220ms ease;
      will-change: transform;
      --uiHide: 390px; /* JSë¡œ ì‹¤ì œ í­ ê³„ì‚°í•´ì„œ ë®ì–´ì”€ */
    }
    #ui.collapsed{ transform: translateX(calc(-1 * var(--uiHide))); }

    #ui::-webkit-scrollbar{ width:6px; }
    #ui::-webkit-scrollbar-thumb{ background:#cfcfcf; border-radius:10px; }

    /* âœ… íŒ¨ë„ í† ê¸€ ë²„íŠ¼ (í•­ìƒ ë³´ì´ê²Œ) */
    .uiToggle{
      position: fixed;
      left: 12px;
      top: 76px;
      z-index: 2001;
      width: 40px;
      height: 40px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.96);
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      font-weight: 900;
      cursor: pointer;
    }
    .uiToggle:hover{ background:#f6f6f6; }

    .topRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .title{ font-weight:800; font-size:16px; display:flex; align-items:center; gap:8px; }
    .ver{ font-size:11px; padding:2px 6px; border-radius:6px; background:#111827; color:#fff; }

    .topBtns{ display:flex; gap:6px; }
    .miniBtn{
      border:1px solid var(--line); background:#fff; color:var(--ink);
      padding:7px 9px; border-radius:10px; font-size:12px;
    }
    .miniBtn:hover{ background:#f6f6f6; }
    .miniBtn.danger{ border-color:#ffd1d1; color:var(--danger); }
    .miniBtn.primary{ border-color:#c7ddff; color:#1d4ed8; }

    .modeRow{ margin-top:10px; display:flex; gap:8px; }
    .modeBtn{
      flex:1; border:none; border-radius:12px; padding:10px 0;
      background:#e9e9e9; color:#666; font-weight:900;
    }
    .modeBtn.active{ background:var(--btn); color:#fff; }

    .block{ margin-top:10px; border:1px solid var(--line); border-radius:12px; padding:10px; background:#fff; }
    .hint{ font-size:12px; color:var(--muted); line-height:1.5; }

    input[type=number]{
      width:100%;
      box-sizing:border-box;
      padding:10px;
      border:1px solid #d8d8d8;
      border-radius:12px;
      font-size:12px;
      outline:none;
    }
    input[type=number]:focus{ border-color:#a7c7ff; box-shadow:0 0 0 3px rgba(37,99,235,.12); }

    textarea{
      width:100%; height:170px; box-sizing:border-box;
      margin-top:8px;
      border:1px solid #d8d8d8; border-radius:12px;
      padding:10px; font-size:12px; resize:vertical;
      user-select:text;
    }
    .rowBtns{ display:flex; gap:8px; margin-top:8px; }
    .rowBtns button{ flex:1; }

    #buildBtn{
      width:100%; margin-top:10px;
      border:none; border-radius:12px;
      padding:12px 0; font-weight:900; font-size:14px;
      background:var(--btn2); color:#fff;
    }
    #buildBtn:hover{ filter:brightness(0.95); }

    #status{
      margin-top:10px; font-size:12px; line-height:1.45;
      color:var(--muted);
      background:#f8fafc; border:1px solid #eef2ff;
      padding:10px; border-radius:12px;
    }
    #status b{ color:var(--ink); }
    .ok{ color:var(--ok); font-weight:900; }
    .bad{ color:var(--danger); font-weight:900; }

    details{ margin-top:10px; }
    summary{
      cursor:pointer; font-weight:900; font-size:13px;
      list-style:none;
    }
    summary::-webkit-details-marker{ display:none; }
    .detailsBody{
      margin-top:8px; font-size:12px; color:var(--muted); line-height:1.6;
      border:1px dashed #e5e7eb; border-radius:12px; padding:10px; background:#fafafa;
    }
    kbd{ background:#fff; border:1px solid #ddd; padding:1px 6px; border-radius:6px; font-family:monospace; font-weight:900; }

    /* âœ… ì²´í¬ë°•ìŠ¤(ìƒˆë¡œê³ ì¹¨ ìë™ ì´ˆê¸°í™”) */
    .chkRow{ display:flex; gap:8px; align-items:center; margin-top:10px; }
    .chkRow input{ width:16px; height:16px; }
    .chkRow label{ font-size:12px; color:#444; font-weight:800; user-select:none; }

    /* Viewer */
    #viewer{ position:fixed; inset:0; z-index:1; }

    #twod{ position:absolute; inset:0; overflow:auto; display:none; background:#fff;
      background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px);
      background-size:40px 40px;
    }
    #three{ position:absolute; inset:0; display:block; }
    #elev{ position:absolute; inset:0; overflow:auto; display:none; background:#fff;
      background-image: linear-gradient(#f0f0f0 1px, transparent 1px), linear-gradient(90deg, #f0f0f0 1px, transparent 1px);
      background-size:40px 40px;
      padding:18px 18px 80px 18px;
      box-sizing:border-box;
    }

    .room2d{
      position:absolute; border:2px solid #666; box-shadow:2px 2px 6px rgba(0,0,0,.12);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-size:12px; padding:6px; cursor:grab; user-select:none; touch-action:none;
    }
    .room2d.dragging{ cursor:grabbing; opacity:.85; z-index:999; box-shadow:6px 6px 16px rgba(0,0,0,.18); }

    /* ì…ë©´ ì¹´ë“œ */
    .elevHeader{
      position:sticky; top:0; z-index:5;
      background:rgba(255,255,255,.92);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow:0 6px 18px rgba(0,0,0,.08);
      backdrop-filter: blur(6px);
      margin-bottom:14px;
    }
    .elevGrid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(330px, 1fr));
      gap:14px;
    }
    .elevCard{
      background:#fff;
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 22px rgba(0,0,0,.07);
    }
    .elevTitle{ font-weight:900; font-size:14px; margin-bottom:8px; }
    .elevMeta{ font-size:12px; color:var(--muted); margin-bottom:10px; line-height:1.4; }
    .wallRow{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .wallBox{
      border:1px solid #e5e7eb;
      border-radius:12px;
      padding:10px;
      background:#fafafa;
    }
    .wallLabel{ font-weight:900; font-size:12px; margin-bottom:6px; color:#111; }
    .wallSvgWrap{ width:100%; overflow:hidden; cursor:pointer; }
    .warn{ margin-top:8px; font-size:12px; color:var(--danger); font-weight:900; }
    .good{ margin-top:8px; font-size:12px; color:var(--ok); font-weight:900; }
    .note{ margin-top:8px; font-size:12px; color:#374151; font-weight:900; }

    /* Tooltip (3D) */
    #tooltip{
      position:fixed; display:none; z-index:9999; pointer-events:none;
      background:rgba(17,24,39,.95); color:#fff;
      padding:10px 12px; border-radius:12px;
      font-size:12px; line-height:1.55;
      box-shadow:0 18px 50px rgba(0,0,0,.35);
      min-width:260px;
      border:1px solid rgba(255,255,255,.12);
    }
    #tooltip b{ display:block; font-size:13px; margin-bottom:6px; color:#fde68a; }
    .ttRow{ display:flex; justify-content:space-between; gap:12px; }
    .ttLbl{ color:#cbd5e1; }
    .ttVal{ font-weight:900; }

    /* âœ… ì¤Œ HUD (2D/ì…ë©´) */
    #zoomHud{
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 1600;
      display: none;
      gap: 6px;
      align-items: center;
      background: rgba(255,255,255,.94);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 8px 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      user-select:none;
    }
    #zoomHud button{
      width: 34px; height: 34px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: #fff;
      font-weight: 900;
      cursor: pointer;
    }
    #zoomHud button:hover{ background:#f6f6f6; }
    #zoomLabel{
      font-size: 12px;
      font-weight: 900;
      min-width: 64px;
      text-align: center;
      color:#111;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="tooltip"></div>

  <!-- âœ… ì¤Œ HUD -->
  <div id="zoomHud" aria-label="Zoom controls">
    <button id="zoomOut" title="ì¶•ì†Œ">âˆ’</button>
    <span id="zoomLabel">100%</span>
    <button id="zoomIn" title="í™•ëŒ€">ï¼‹</button>
    <button id="zoomReset" title="100%">âŸ²</button>
  </div>

  <!-- âœ… ë©”ë‰´ ì ‘ê¸°/í¼ì¹˜ê¸° ë²„íŠ¼ -->
  <button id="uiToggle" class="uiToggle" title="ë©”ë‰´ ì ‘ê¸°">â—€</button>

  <div id="ui">
    <div class="topRow">
      <div class="title">ëš±ëšœë£¨ì˜ ë„ë©´ì†Œìƒìˆ  <span class="ver">v2.41</span></div>
      <div class="topBtns">
        <button id="resetBtn" class="miniBtn danger">ì´ˆê¸°í™”</button>
        <button id="jsonLoadBtn" class="miniBtn">JSON ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button id="jsonSaveBtn" class="miniBtn primary">JSON ì €ì¥</button>
        <input id="jsonFile" type="file" accept="application/json" style="display:none" />
      </div>
    </div>

    <div class="modeRow">
      <button id="mode2d" class="modeBtn">ğŸ“Š 2D</button>
      <button id="mode3d" class="modeBtn active">ğŸ§Š 3D</button>
      <button id="modeElev" class="modeBtn">ğŸ§± ì…ë©´</button>
    </div>

    <div class="block">
      <div class="hint">
        <b>ë”± 2ë‹¨ê³„ë§Œ í•˜ì„¸ìš”.</b><br/>
        1) ì•„ë˜ ì¹¸ì— â€œë°© ëª©ë¡â€ ë¶™ì—¬ë„£ê¸°<br/>
        2) <b>[ë„ë©´ ìƒì„±]</b> ëˆ„ë¥´ê¸°
      </div>

      <!-- âœ… ìƒˆë¡œê³ ì¹¨ ìë™ ì´ˆê¸°í™” ì˜µì…˜ -->
      <div class="chkRow">
        <input id="autoClear" type="checkbox" checked />
        <label for="autoClear">ìƒˆë¡œê³ ì¹¨(F5)í•˜ë©´ ì…ë ¥/ë„í˜• ìë™ ì´ˆê¸°í™”</label>
      </div>

      <!-- ë²½ë‘ê»˜ ì…ë ¥ (ê¸°ë³¸ 200mm) -->
      <div style="margin-top:10px;">
        <div style="font-size:12px;font-weight:900;color:#111;">ë²½ë‘ê»˜(mm) <span style="font-weight:700;color:#666;">(ê¸°ë³¸ 200, ë¹„ì›Œë„ ìë™ 200)</span></div>
        <input id="wallThk" type="number" value="200" min="50" max="500" step="10" />
        <div class="hint" style="margin-top:6px;">
          Â· 200ì²˜ëŸ¼ í° ê°’ì€ <b>mm</b>ë¡œ ë³´ê³  0.2më¡œ ë³€í™˜í•©ë‹ˆë‹¤.<br/>
          Â· 0.2ì²˜ëŸ¼ ì‘ì€ ê°’ì€ <b>m</b>ë¡œ ë´…ë‹ˆë‹¤.
        </div>
      </div>

      <textarea id="dataInput" placeholder="âœ… ì œì¼ ì‰¬ìš´ ì…ë ¥(í—¤ë” ì—†ì–´ë„ ë¨)
ê±°ì‹¤ 5.0 4.0
ë°©1 2.4 2.4

âœ… ì—‘ì…€/êµ¬ê¸€ì‹œíŠ¸ í‘œ í†µì§¸ë¡œ ë³µì‚¬ë„ OK
ê³µê°„ID	ê³µê°„ëª…	ê°€ë¡œ(m)	ì„¸ë¡œ(m)	ë²½ë†’ì´(m)	ì°½ë©´ì (ã¡)

âœ… ì°½ì„ 'ê·¸ë¦¼(ì§„ì§œ ì°½)'ìœ¼ë¡œ ë„£ê³  ì‹¶ìœ¼ë©´
[ì…ë©´] ëª¨ë“œì—ì„œ ë²½ ì¹´ë“œì˜ [ + ì°½ ]ì„ ëˆŒëŸ¬ì„œ
ê°€ë¡œ/ì„¸ë¡œë§Œ ì…ë ¥í•˜ì„¸ìš” (ê¸°ë³¸: ì¤‘ì•™ + sill 0.9m)"></textarea>

      <div class="rowBtns">
        <button id="pasteBtn" class="miniBtn">ğŸ“‹ í´ë¦½ë³´ë“œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button id="sampleBtn" class="miniBtn">ğŸ§ª ìƒ˜í”Œ ë„£ê¸°</button>
        <button id="clearInputBtn" class="miniBtn">ğŸ§½ ì…ë ¥ ì§€ìš°ê¸°</button>
      </div>

      <button id="buildBtn">ğŸ—ï¸ ë„ë©´ ìƒì„±</button>

      <div id="status">
        <b>ìƒíƒœ</b><br/>
        ì•„ì§ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìœ„ ì¹¸ì— ë¶™ì—¬ë„£ê³  [ë„ë©´ ìƒì„±]ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
      </div>

      <details>
        <summary>ì‚¬ìš©ë²• (30ì´ˆ)</summary>
        <div class="detailsBody">
          1) ì—‘ì…€/êµ¬ê¸€ì‹œíŠ¸ì—ì„œ <b>ë°© ëª©ë¡ í‘œ</b>ë¥¼ ë“œë˜ê·¸í•´ì„œ ë³µì‚¬<br/>
          2) ì´ í˜ì´ì§€ì— ë¶™ì—¬ë„£ê¸°<br/>
          3) <b>[ë„ë©´ ìƒì„±]</b><br/><br/>
          - 2D: ë°© ì¡°ê° ë“œë˜ê·¸ë¡œ ë°°ì¹˜ (íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ, <kbd>Shift</kbd>+íœ ì€ ìŠ¤í¬ë¡¤)<br/>
          - 3D: <kbd>Shift</kbd> ëˆ„ë¥´ê³  ë“œë˜ê·¸í•˜ë©´ ë°© ì´ë™, ëª¨ë°”ì¼ì€ í•€ì¹˜ ì¤Œ OK<br/>
          - ì…ë©´: ì „ê°œë„(4ë©´) ìë™ ìƒì„±, <kbd>Ctrl</kbd>+íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ<br/><br/>
          âœ… ì°½ ë„£ê¸°: <b>[ì…ë©´]</b>ì—ì„œ ë²½ ì¹´ë“œì˜ <b>[+ ì°½]</b> ëˆ„ë¥´ê³  <b>ê°€ë¡œ/ì„¸ë¡œ</b>ë§Œ ì…ë ¥í•˜ì„¸ìš”.<br/>
          (x/sillì€ ì„ íƒ, ë¹„ìš°ë©´ ìë™ ì¤‘ì•™ + sill 0.9m)<br/><br/>
          íŒ: ì…ë©´ì€ í™”ë©´ì´ ë„“ì–´ì•¼ í¸í•´ì„œ <b>ìë™ìœ¼ë¡œ ì™¼ìª½ ë©”ë‰´ê°€ ì ‘í™ë‹ˆë‹¤.</b><br/>
          ë‹¤ì‹œ í¼ì¹˜ë ¤ë©´ ì™¼ìª½ ìœ„ <b>â—€/â–¶</b> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.
        </div>
      </details>

      <details>
        <summary>ë©´ì /ë³´ì • ì„¤ëª… (ì¤‘ìš”)</summary>
        <div class="detailsBody">
          âœ… <b>ìˆœë©´ì (ì—‘ì…€ ë™ì¼)</b> = ê°€ë¡œÃ—ì„¸ë¡œ<br/>
          âš ï¸ <b>ë²½ í¬í•¨ ì¶”ì •ë©´ì (ì°¸ê³ )</b> = (ê°€ë¡œ+2t)Ã—(ì„¸ë¡œ+2t)<br/><br/>
          ë‹¨, ë°©ë¼ë¦¬ ë¶™ì–´ ìˆìœ¼ë©´ ê³µìœ ë²½ì´ ìƒê¸°ë¯€ë¡œ<br/>
          â€œë²½ í¬í•¨ ì¶”ì •ë©´ì â€ì€ <b>ë°©ë³„ ìµœëŒ€ì¹˜</b> ëŠë‚Œìœ¼ë¡œ ë³´ì„¸ìš”(ì¤‘ë³µ ê°€ëŠ¥).<br/><br/>
          ì´ ì‚¬ì´íŠ¸ëŠ” <b>ì—‘ì…€ê³¼ ê°™ì€ ìˆœë©´ì </b>ì„ ê¸°ë³¸ìœ¼ë¡œ ìœ ì§€í•˜ê³ ,<br/>
          ë²½ë‘ê»˜ëŠ” <b>3D ë²½ ë‘ê»˜/ë²½ì²´ë¶€í”¼ ì¶”ì •</b>ì— íŠ¹íˆ ìœ ìš©í•˜ê²Œ ì“°ì…ë‹ˆë‹¤.
        </div>
      </details>

      <details>
        <summary>ë°ì´í„° í˜•ì‹ (ì¤‘ìš”)</summary>
        <div class="detailsBody">
          ìµœì†Œ 3ê°œë§Œ ìˆì–´ë„ ë©ë‹ˆë‹¤: <b>ë°©ì´ë¦„ / ê°€ë¡œ / ì„¸ë¡œ</b><br/>
          (ID/ë†’ì´/ì°½ë©´ì ì€ ì—†ì–´ë„ ìë™ ì²˜ë¦¬)<br/><br/>

          âœ… ì°½(ê³„ì‚°ìš©) ì…ë ¥<br/>
          - <b>ì°½ë©´ì (ã¡)</b>ì€ ê³„ì‚°ìš©ì…ë‹ˆë‹¤. (ë²½ë©´ì ì—ì„œ ë¹¼ëŠ” ìš©ë„)<br/>
          - ì°½ì„ <b>ê·¸ë¦¼</b>ìœ¼ë¡œ ë„£ê³  ì‹¶ìœ¼ë©´ <b>[ì…ë©´]</b>ì—ì„œ ë²½ ì¹´ë“œì˜ <b>[+ ì°½]</b>ì„ ì‚¬ìš©í•˜ì„¸ìš”.
        </div>
      </details>

      <details>
        <summary>ë‹¨ì¶•í‚¤</summary>
        <div class="detailsBody">
          <b>ê³µí†µ</b>: <kbd>P</kbd> ìº¡ì²˜ ì €ì¥ ğŸ“¸<br/>
          <b>3D</b>: <kbd>Shift</kbd>+ë“œë˜ê·¸ ë°© ì´ë™ / <kbd>L</kbd> ë¼ë²¨ í† ê¸€ / <kbd>G</kbd> ì •ë‹µìœ ë ¹ í† ê¸€
        </div>
      </details>

      <details>
        <summary>ë‹¤ìš´ë¡œë“œ/ìƒë‹´</summary>
        <div class="detailsBody">
          ğŸ“‚ ì—‘ì…€í‚¤íŠ¸: <a href="https://drive.google.com/file/d/112Y3BEiE_1ooNrF5tPZd6SnDRHyXcrDg/view?usp=sharing" target="_blank">ë‹¤ìš´</a><br/>
          ğŸ“‘ êµ¬ê¸€ì‹œíŠ¸ ì‚¬ë³¸: <a href="https://docs.google.com/spreadsheets/d/1GW5nJHgax0XTXOPyyVusVr_WKob3S5URJG1lSiAM6bE/copy" target="_blank">ì‚¬ë³¸ ë§Œë“¤ê¸°</a><br/>
          ğŸ’¬ í†¡í†¡: <a href="https://talk.naver.com/W4HB1I" target="_blank">ìƒë‹´í•˜ê¸°</a><br/>
          ğŸŒ¿ ê·¸ë¦°ë¦¬ëª¨ë¸ë§: <a href="https://yugy.store" target="_blank">yugy.store</a>
        </div>
      </details>
    </div>
  </div>

  <div id="viewer">
    <div id="twod"></div>
    <div id="three"></div>
    <div id="elev"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // -----------------------------
    // 0) ìƒíƒœ/íŒ”ë ˆíŠ¸
    // -----------------------------
    const EXCEL_COLORS = [
      "#FFCCCC","#FFE5CC","#FFFFCC","#E5FFCC","#CCFFCC","#CCFFE5","#CCFFFF","#CCE5FF","#CCCCFF","#E5CCFF",
      "#FFCCFF","#FFCCE5","#FFB2B2","#FFD6A5","#FFEF9F","#CAE799","#A6E3A1","#99DDCC","#9FDBFF","#ADC1FF",
      "#C8B2FF","#E0B2FF","#FFB2F5","#FFB2D7","#FFB2B2","#FF8282","#FFAA64","#FFD246","#B4DC5A","#78D296"
    ];

    let mode = '3d';
    /**
     * globalData row:
     * {
     *  id,name,w,d,h,
     *  winTotal, winAreaPlaced, win:{front,back,left,right},  // (ê³„ì‚°ìš©) ì°½ë©´ì 
     *  windows:{front:[],back:[],left:[],right:[]},           // (í‘œì‹œìš©) ì°½ ì‚¬ê°í˜•
     *  winPlaced,                                             // windows ì¡´ì¬ ì—¬ë¶€
     *  x2d,y2d
     * }
     */
    let globalData = [];
    let globalWallThicknessMm = 200;
    let globalWallThicknessM = 0.2;

    const $ = (id) => document.getElementById(id);
    const statusEl = $('status');
    const inputEl = $('dataInput');
    const tooltip = $('tooltip');
    const ui = $('ui');
    const uiToggle = $('uiToggle');
    const autoClearEl = $('autoClear');

    // Zoom HUD
    const zoomHud = $('zoomHud');
    const zoomLabel = $('zoomLabel');
    const zoomInBtn = $('zoomIn');
    const zoomOutBtn = $('zoomOut');
    const zoomResetBtn = $('zoomReset');

    function setStatus(html){ statusEl.innerHTML = html; }

    // -----------------------------
    // âœ… UI ì ‘ê¸°/í¼ì¹˜ê¸°
    // -----------------------------
    let uiCollapsed = localStorage.getItem('uiCollapsed') === '1';

    function calcUiHide(){
      const w = ui.getBoundingClientRect().width || 360;
      ui.style.setProperty('--uiHide', (w + 16) + 'px');
    }

    function applyUiCollapsed(){
      ui.classList.toggle('collapsed', uiCollapsed);
      uiToggle.textContent = uiCollapsed ? 'â–¶' : 'â—€';
      uiToggle.title = uiCollapsed ? 'ë©”ë‰´ í¼ì¹˜ê¸°' : 'ë©”ë‰´ ì ‘ê¸°';
    }

    function setUiCollapsed(next){
      uiCollapsed = !!next;
      localStorage.setItem('uiCollapsed', uiCollapsed ? '1' : '0');
      calcUiHide();
      applyUiCollapsed();
    }

    uiToggle.addEventListener('click', ()=> setUiCollapsed(!uiCollapsed));

    // -----------------------------
    // âœ… ìƒˆë¡œê³ ì¹¨ ìë™ ì´ˆê¸°í™”(ì˜µì…˜)
    // -----------------------------
    const savedAutoClear = localStorage.getItem('autoClearOnReload');
    autoClearEl.checked = (savedAutoClear === null) ? true : (savedAutoClear === '1');
    autoClearEl.addEventListener('change', ()=>{
      localStorage.setItem('autoClearOnReload', autoClearEl.checked ? '1' : '0');
    });

    // -----------------------------
    // âœ… 2D/ì…ë©´ ì¤Œ
    // -----------------------------
    let twodZoom = parseFloat(localStorage.getItem('twodZoom') || '1') || 1;
    let elevZoom = parseFloat(localStorage.getItem('elevZoom') || '1') || 1;

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function clampZoom(z){ return clamp(z, 0.35, 3.2); }

    function setZoomForMode(z){
      if (mode === '2d'){
        twodZoom = clampZoom(z);
        $('twod').style.zoom = String(twodZoom);
        localStorage.setItem('twodZoom', String(twodZoom));
        zoomLabel.textContent = `${Math.round(twodZoom*100)}%`;
      } else if (mode === 'elev'){
        elevZoom = clampZoom(z);
        $('elev').style.zoom = String(elevZoom);
        localStorage.setItem('elevZoom', String(elevZoom));
        zoomLabel.textContent = `${Math.round(elevZoom*100)}%`;
      }
    }

    function syncZoomHud(){
      const on = (mode==='2d' || mode==='elev');
      zoomHud.style.display = on ? 'flex' : 'none';
      if (!on) return;
      if (mode==='2d') zoomLabel.textContent = `${Math.round(twodZoom*100)}%`;
      if (mode==='elev') zoomLabel.textContent = `${Math.round(elevZoom*100)}%`;
    }

    zoomInBtn.addEventListener('click', ()=> setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 1.12));
    zoomOutBtn.addEventListener('click', ()=> setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 0.90));
    zoomResetBtn.addEventListener('click', ()=> setZoomForMode(1));

    function attachWheelZoom(el, modeName){
      el.addEventListener('wheel', (e)=>{
        if (modeName === '2d'){
          if (e.shiftKey) return;
          e.preventDefault();
          const dir = e.deltaY < 0 ? 1.10 : 0.92;
          setZoomForMode(twodZoom * dir);
          return;
        }
        if (modeName === 'elev'){
          if (!(e.ctrlKey || e.metaKey)) return;
          e.preventDefault();
          const dir = e.deltaY < 0 ? 1.10 : 0.92;
          setZoomForMode(elevZoom * dir);
        }
      }, { passive:false });
    }

    function attachPinchZoom(el, getZ, setZ){
      let pinchStartDist = 0;
      let pinchStartZoom = 1;

      function dist(t1,t2){
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.hypot(dx,dy);
      }

      el.addEventListener('touchstart', (e)=>{
        if (e.touches && e.touches.length === 2){
          pinchStartDist = dist(e.touches[0], e.touches[1]);
          pinchStartZoom = getZ();
        }
      }, { passive:false });

      el.addEventListener('touchmove', (e)=>{
        if (e.touches && e.touches.length === 2){
          e.preventDefault();
          const d = dist(e.touches[0], e.touches[1]);
          if (!pinchStartDist) return;
          const ratio = d / pinchStartDist;
          setZ(pinchStartZoom * ratio);
        }
      }, { passive:false });
    }

    // -----------------------------
    // 1) ë‹¨ìœ„/íŒŒì„œ
    // -----------------------------
    function numOnly(v){
      if (v === null || v === undefined) return '';
      return String(v).replace(/[^0-9.\-]/g,'').trim();
    }
    function smartUnit(v){
      const s = numOnly(v);
      const n = parseFloat(s);
      if (!isFinite(n) || n <= 0) return 0;
      if (n > 100) return n / 1000;
      return n;
    }
    function smartThickness(v, fallbackM){
      const s = numOnly(v);
      const n = parseFloat(s);
      if (!isFinite(n) || n <= 0) return fallbackM;
      if (n > 10) return n / 1000;
      return n;
    }
    function getGlobalThickness(){
      const raw = $('wallThk').value;
      let t = smartThickness(raw, 0.2);
      if (!isFinite(t) || t <= 0) t = 0.2;
      if (t < 0.03) t = 0.03;
      if (t > 1.0) t = 1.0;
      globalWallThicknessM = t;
      globalWallThicknessMm = Math.round(t*1000);
      return t;
    }

    function parseAreaCell(v){
      const n = parseFloat(numOnly(v));
      return (isFinite(n) && n > 0) ? n : 0;
    }
    function normFace(v){
      const s = String(v ?? '').trim().toLowerCase();
      if (!s) return null;
      if (/^(f|front)$/.test(s) || /ì•|ì „ë©´/.test(s)) return 'front';
      if (/^(b|back)$/.test(s)  || /ë’¤|í›„ë©´/.test(s)) return 'back';
      if (/^(l|left)$/.test(s)  || /ì¢Œ|ì™¼/.test(s)) return 'left';
      if (/^(r|right)$/.test(s) || /ìš°|ì˜¤ë¥¸/.test(s)) return 'right';
      return null;
    }

    function splitCols(line){
      const t = (line || '').trim();
      if (!t) return null;
      if (t.includes('\t')) return t.split('\t').map(x=>x.trim());
      if (t.includes(',')) return t.split(',').map(x=>x.trim());
      return t.split(/\s+/).map(x=>x.trim());
    }

    function detectHeader(cols){
      const lower = cols.map(c => String(c).toLowerCase().replace(/\s/g,'').replace(/[()]/g,''));
      const map = {};
      lower.forEach((c,i)=>{
        if (/ê³µê°„id|ë°©id|id|ë²ˆí˜¸/.test(c)) map.id=i;
        if (/ê³µê°„ëª…|ë°©ì´ë¦„|ì´ë¦„|name/.test(c)) map.name=i;
        if (/ê°€ë¡œ|width|w|ê¸¸ì´/.test(c)) map.w=i;
        if (/ì„¸ë¡œ|depth|d|ë„ˆë¹„/.test(c)) map.d=i;
        if (/ë²½ë†’ì´|ë†’ì´|height|h/.test(c)) map.h=i;

        if (/ì°½ë©´ì |ì°½ë¬¸ë©´ì |windowarea|winarea/.test(c)) map.winTotal=i;
        if (/ì°½ë©´|ì°½ìœ„ì¹˜|ì°½ë°©í–¥|winface|windowface|face/.test(c)) map.winFace=i;

        if (/ì°½ì•|ì°½ë©´ì ì•|ì „ë©´ì°½|winfront|windowfront/.test(c)) map.winFront=i;
        if (/ì°½ë’¤|ì°½ë©´ì ë’¤|í›„ë©´ì°½|winback|windowback/.test(c)) map.winBack=i;
        if (/ì°½ì¢Œ|ì°½ë©´ì ì¢Œ|ì¢Œì¸¡ì°½|winleft|windowleft/.test(c)) map.winLeft=i;
        if (/ì°½ìš°|ì°½ë©´ì ìš°|ìš°ì¸¡ì°½|winright|windowright/.test(c)) map.winRight=i;
      });
      if (map.name !== undefined && map.w !== undefined && map.d !== undefined) return map;
      return null;
    }

    function makeEmptyWindows(){
      return { front:[], back:[], left:[], right:[] };
    }
    function ensureRoomWindows(r){
      if (!r.windows) r.windows = makeEmptyWindows();
      for (const k of ['front','back','left','right']){
        if (!Array.isArray(r.windows[k])) r.windows[k] = [];
      }
      r.winPlaced = (r.windows.front.length + r.windows.back.length + r.windows.left.length + r.windows.right.length) > 0;
      if (r.winAreaPlaced === undefined) r.winAreaPlaced = false;
      if (!r.win) r.win = {front:0,back:0,left:0,right:0};
      if (!isFinite(r.winTotal)) r.winTotal = 0;
      if (!isFinite(r.h) || r.h<=0) r.h = 2.3;
      return r;
    }
    function rectAreaSum(r){
      ensureRoomWindows(r);
      let s = 0;
      for (const k of ['front','back','left','right']){
        for (const w of r.windows[k]){
          const a = (parseFloat(w.w)||0) * (parseFloat(w.h)||0);
          if (isFinite(a) && a>0) s += a;
        }
      }
      return s;
    }

    // âœ… ì´ˆë³´ìš©: í—¤ë” ì—†ì–´ë„ "ë°©ì´ë¦„ ê°€ë¡œ ì„¸ë¡œ" 3ì—´ì´ë©´ ì¸ì‹
    function parseLooseRow(cols){
      const idTry = parseInt(numOnly(cols[0] ?? ''), 10);
      const nameTry = String(cols[1] ?? '').trim();

      const wTry1 = smartUnit(cols[2]);
      const dTry1 = smartUnit(cols[3]);
      if (isFinite(idTry) && idTry > 0 && nameTry && wTry1 > 0 && dTry1 > 0){
        let h = smartUnit(cols[4]); if (!h) h = 2.3;
        let winTotal = parseAreaCell(cols[5]);
        return ensureRoomWindows({
          id:idTry, name:nameTry, w:wTry1, d:dTry1, h,
          winTotal,
          winAreaPlaced:false,
          win:{front:0,back:0,left:0,right:0},
          windows: makeEmptyWindows(),
          winPlaced:false
        });
      }

      const name2 = String(cols[0] ?? '').trim();
      const wTry2 = smartUnit(cols[1]);
      const dTry2 = smartUnit(cols[2]);
      if (name2 && wTry2 > 0 && dTry2 > 0){
        let h = smartUnit(cols[3]); if (!h) h = 2.3;
        let winTotal = parseAreaCell(cols[4]);
        return ensureRoomWindows({
          id:0, name:name2, w:wTry2, d:dTry2, h,
          winTotal,
          winAreaPlaced:false,
          win:{front:0,back:0,left:0,right:0},
          windows: makeEmptyWindows(),
          winPlaced:false
        });
      }

      return null;
    }

    function parseText(text){
      const lines = String(text||'').split(/\r?\n/);
      const parsed = [];
      let headerMap = null;
      let autoId = 1;
      let skipped = 0;

      for (const line of lines){
        const cols = splitCols(line);
        if (!cols) continue;

        if (!headerMap){
          const hm = detectHeader(cols);
          if (hm){
            headerMap = hm;
            continue;
          }
        }

        if (!headerMap){
          const loose = parseLooseRow(cols);
          if (loose){
            if (!loose.id) loose.id = autoId;
            parsed.push(loose);
            autoId = Math.max(autoId, loose.id + 1);
          } else {
            skipped++;
          }
          continue;
        }

        const idxId = headerMap?.id ?? 0;
        const idxName = headerMap?.name ?? 1;
        const idxW = headerMap?.w ?? 2;
        const idxD = headerMap?.d ?? 3;
        const idxH = headerMap?.h ?? 4;

        const name = String(cols[idxName] ?? '').trim();
        if (!name){ skipped++; continue; }

        let id = parseInt(numOnly(cols[idxId] ?? ''),10);
        if (!isFinite(id) || id <= 0) id = autoId;

        const w = smartUnit(cols[idxW]);
        const d = smartUnit(cols[idxD]);
        let h = smartUnit(cols[idxH]);
        if (!h) h = 2.3;

        const idxWinTotal = headerMap?.winTotal;
        const idxWinFace  = headerMap?.winFace;
        const idxWinFront = headerMap?.winFront;
        const idxWinBack  = headerMap?.winBack;
        const idxWinLeft  = headerMap?.winLeft;
        const idxWinRight = headerMap?.winRight;

        const win = { front:0, back:0, left:0, right:0 };
        let winTotal = 0;
        let winAreaPlaced = false;

        const wf = (idxWinFront !== undefined) ? parseAreaCell(cols[idxWinFront]) : 0;
        const wb = (idxWinBack  !== undefined) ? parseAreaCell(cols[idxWinBack])  : 0;
        const wl = (idxWinLeft  !== undefined) ? parseAreaCell(cols[idxWinLeft])  : 0;
        const wr = (idxWinRight !== undefined) ? parseAreaCell(cols[idxWinRight]) : 0;

        if (wf+wb+wl+wr > 0){
          win.front = wf; win.back = wb; win.left = wl; win.right = wr;
          winTotal = wf+wb+wl+wr;
          winAreaPlaced = true;
        } else {
          if (idxWinTotal !== undefined){
            winTotal = parseAreaCell(cols[idxWinTotal]);
          } else {
            const joined = cols.join(' ');
            const m = joined.match(/ì°½ë©´ì \s*=?\s*([0-9.]+)/);
            if (m){
              const wa = parseFloat(m[1]);
              if (isFinite(wa) && wa > 0) winTotal = wa;
            }
          }

          if (winTotal > 0 && idxWinFace !== undefined){
            const face = normFace(cols[idxWinFace]);
            if (face){
              win[face] = winTotal;
              winAreaPlaced = true;
            }
          }
        }

        if (w > 0 && d > 0){
          parsed.push(ensureRoomWindows({
            id, name, w, d, h,
            winTotal,
            winAreaPlaced,
            win,
            windows: makeEmptyWindows(),
            winPlaced:false
          }));
          autoId = Math.max(autoId, id + 1);
        } else {
          skipped++;
        }
      }
      return { parsed, skipped };
    }

    // -----------------------------
    // 2) ì´ˆê¸°í™”
    // -----------------------------
    const twod = $('twod');
    const elev = $('elev');
    const threeEl = $('three');

    function setDefaultStatus(){
      setStatus(`<b>ìƒíƒœ</b><br/>ì•„ì§ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ìœ„ ì¹¸ì— ë¶™ì—¬ë„£ê³  <b>[ë„ë©´ ìƒì„±]</b>ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.`);
    }

    function hardReset({ clearInput=true } = {}){
      twod.innerHTML = '';
      elev.innerHTML = '';

      pieces.forEach(p => scene.remove(p));
      ghosts.forEach(g => scene.remove(g));
      pieces = []; ghosts = []; hitMeshes = []; labels3D = [];
      dragging = false;
      draggedGroup = null;

      globalData = [];
      if (clearInput) inputEl.value = '';

      tooltip.style.display = 'none';
      setStatus(`<b>ìƒíƒœ</b><br/>ì´ˆê¸°í™” ì™„ë£Œ. ë‹¤ì‹œ ë¶™ì—¬ë„£ê³  <b>[ë„ë©´ ìƒì„±]</b> ëˆ„ë¥´ì„¸ìš”.`);
    }

    function maybeAutoClearOnReload(){
      if (!autoClearEl.checked) return;
      const clear = ()=>{
        inputEl.value = '';
        hardReset({ clearInput:true });
        setDefaultStatus();
      };
      clear();
      setTimeout(clear, 0);
      setTimeout(clear, 80);
    }

    window.addEventListener('pageshow', ()=>{
      maybeAutoClearOnReload();
    });

    // -----------------------------
    // 3) 2D
    // -----------------------------
    const SCALE_2D = 40;
    let active2D = null;
    let active2DOffset = { x:0, y:0 };

    function build2D(){
      twod.innerHTML = '';
      if (!globalData.length) return;

      const START_X = 380, START_Y = 40, LIMIT = 980, GAP = 18;
      let x = START_X, y = START_Y, rowH = 0;

      const title = document.createElement('div');
      title.style.position='absolute';
      title.style.left='16px';
      title.style.top='10px';
      title.style.fontWeight='900';
      title.style.fontSize='14px';
      title.innerHTML='2D ëª¨ë“œ: ë°© ì¡°ê°ì„ ë“œë˜ê·¸ë¡œ ë§ì¶”ê¸° <span style="font-size:12px;color:#666;font-weight:800;">(íœ =í™•ëŒ€/ì¶•ì†Œ, Shift+íœ =ìŠ¤í¬ë¡¤)</span>';
      twod.appendChild(title);

      globalData.forEach((d)=>{
        const color = EXCEL_COLORS[(d.id-1) % EXCEL_COLORS.length] || '#ddd';
        const wPx = d.w * SCALE_2D;
        const dPx = d.d * SCALE_2D;

        if (x + wPx > START_X + LIMIT){ x = START_X; y += rowH + GAP; rowH = 0; }

        const div = document.createElement('div');
        div.className='room2d';
        div.dataset.id = d.id;
        div.style.left = (d.x2d ?? (x+'px'));
        div.style.top = (d.y2d ?? (y+'px'));
        div.style.width = wPx+'px';
        div.style.height = dPx+'px';
        div.style.background = color;
        div.innerHTML = `<b>${d.name}</b><span style="font-size:11px;color:#111">(${d.w}Ã—${d.d}m)</span>`;
        twod.appendChild(div);

        x += wPx + GAP;
        rowH = Math.max(rowH, dPx);
      });
    }

    function save2DPositions(){
      const nodes = twod.querySelectorAll('.room2d');
      nodes.forEach(n=>{
        const id = parseInt(n.dataset.id,10);
        const m = globalData.find(x=>x.id===id);
        if (m){
          m.x2d = n.style.left;
          m.y2d = n.style.top;
        }
      });
    }

    twod.addEventListener('pointerdown', (e)=>{
      const target = e.target.closest('.room2d');
      if (!target) return;
      active2D = target;
      active2D.classList.add('dragging');
      const r = active2D.getBoundingClientRect();
      active2DOffset.x = e.clientX - r.left;
      active2DOffset.y = e.clientY - r.top;
    });
    twod.addEventListener('pointermove', (e)=>{
      if (!active2D) return;
      e.preventDefault();
      const c = twod.getBoundingClientRect();
      const cx = e.clientX - c.left + twod.scrollLeft;
      const cy = e.clientY - c.top + twod.scrollTop;
      active2D.style.left = (cx - active2DOffset.x) + 'px';
      active2D.style.top  = (cy - active2DOffset.y) + 'px';
    });
    function end2D(){
      if (!active2D) return;
      active2D.classList.remove('dragging');
      active2D = null;
      save2DPositions();
    }
    twod.addEventListener('pointerup', end2D);
    twod.addEventListener('pointerleave', end2D);

    // -----------------------------
    // 4) ì…ë©´(ì „ê°œë„) + ì°½(ì‚¬ê°í˜•) í‘œì‹œ
    // -----------------------------
    function validateWindowRect(wallW, wallH, win){
      const ww = parseFloat(win.w)||0;
      const wh = parseFloat(win.h)||0;
      const x = parseFloat(win.x)||0;
      const sill = parseFloat(win.sill)||0;
      if (!(ww>0 && wh>0)) return { ok:false, reason:"size" };
      if (ww > wallW*0.999) return { ok:false, reason:"tooWide" };
      if (wh > wallH*0.999) return { ok:false, reason:"tooTall" };
      if (x < -1e-6 || x + ww > wallW + 1e-6) return { ok:false, reason:"xOut" };
      if (sill < -1e-6 || sill + wh > wallH + 1e-6) return { ok:false, reason:"yOut" };
      return { ok:true };
    }

    function wallSVG(wallW, h, windows, colorHex, label){
      const vbW = wallW;
      const vbH = h;

      const marginX = vbW*0.08;
      const marginY = vbH*0.08;
      const innerW = vbW*(1-0.16);
      const innerH = vbH*(1-0.16);
      const sx = innerW / vbW;
      const sy = innerH / vbH;

      const wallStroke = "#111827";
      const wallFill = colorHex;

      let anyInvalid = false;
      const rects = [];

      for (const win of (windows||[])){
        const ww = parseFloat(win.w)||0;
        const wh = parseFloat(win.h)||0;
        let x = parseFloat(win.x);
        let sill = parseFloat(win.sill);

        if (!isFinite(x)) x = (vbW - ww) / 2;
        if (!isFinite(sill)) sill = 0.9;

        const chk = validateWindowRect(vbW, vbH, {w:ww,h:wh,x,sill});
        const invalid = !chk.ok;
        anyInvalid = anyInvalid || invalid;

        const yTop = vbH - (sill + wh);
        rects.push({
          x: marginX + x*sx,
          y: marginY + yTop*sy,
          w: ww*sx,
          h: wh*sy,
          invalid
        });
      }

      const svg = `
        <svg viewBox="0 0 ${vbW} ${vbH}" width="100%" preserveAspectRatio="xMidYMid meet">
          <rect x="${marginX}" y="${marginY}" width="${innerW}" height="${innerH}"
            fill="${wallFill}" fill-opacity="0.75" stroke="${wallStroke}" stroke-width="${Math.max(0.02, vbW*0.01)}" rx="${vbW*0.05}" />
          ${
            rects.map(r=>{
              const fill = r.invalid ? "rgba(255,77,77,0.45)" : "rgba(102,204,255,0.32)";
              const stroke = r.invalid ? "#7f0000" : "#0b4aa2";
              return `<rect x="${r.x}" y="${r.y}" width="${r.w}" height="${r.h}"
                fill="${fill}" stroke="${stroke}" stroke-width="${Math.max(0.02, vbW*0.01)}" rx="${vbW*0.03}" />`;
            }).join('')
          }
          <text x="${vbW*0.5}" y="${vbH*0.12}" text-anchor="middle" font-size="${Math.max(0.18, vbW*0.06)}"
            font-family="Malgun Gothic, system-ui" font-weight="900" fill="#111">${label}</text>
        </svg>
      `;
      return { svg, invalid:anyInvalid };
    }

    function buildElevation(){
      elev.innerHTML = '';
      if (!globalData.length) return;

      const t = globalWallThicknessM;

      const totalFloorNet = globalData.reduce((s,r)=>s + (r.w*r.d), 0);
      const totalFloorGrossEst = globalData.reduce((s,r)=>s + ((r.w+2*t)*(r.d+2*t)), 0);
      const totalWallInner = globalData.reduce((s,r)=>s + ((r.w+r.d)*2*r.h), 0);
      const totalWallOuter = globalData.reduce((s,r)=>s + (((r.w+2*t)+(r.d+2*t))*2*r.h), 0);
      const totalWinInput = globalData.reduce((s,r)=>s + (r.winTotal||0), 0);
      const totalWinRects = globalData.reduce((s,r)=>s + rectAreaSum(r), 0);
      const totalWallVolEst = globalData.reduce((s,r)=>{
        const periOuter = ((r.w+2*t)+(r.d+2*t))*2;
        return s + (periOuter * t * r.h);
      }, 0);

      const header = document.createElement('div');
      header.className = 'elevHeader';
      header.innerHTML = `
        <div style="font-weight:900;font-size:14px;">ì…ë©´(ì „ê°œë„) ìë™ ìƒì„±</div>
        <div style="margin-top:6px;font-size:12px;color:#666;line-height:1.45;">
          ë²½ë‘ê»˜: <b>${(t*1000).toFixed(0)}mm</b><br/>
          ë°© ${globalData.length}ê°œ Â· ìˆœë©´ì (ì—‘ì…€ ë™ì¼) <b>${totalFloorNet.toFixed(2)}ã¡</b> Â· ë²½ í¬í•¨ ì¶”ì •(ì°¸ê³ ) <b>${totalFloorGrossEst.toFixed(2)}ã¡</b><br/>
          ë²½ë©´ì (ë‚´ì¸¡) <b>${totalWallInner.toFixed(2)}ã¡</b> Â· ë²½ë©´ì (ì™¸ì¸¡ ì¶”ì •) <b>${totalWallOuter.toFixed(2)}ã¡</b><br/>
          ì°½ë©´ì (ì…ë ¥,ê³„ì‚°ìš©) <b>${totalWinInput.toFixed(2)}ã¡</b> Â· ì°½(ì‚¬ê°í˜•,í‘œì‹œìš©) <b>${totalWinRects.toFixed(2)}ã¡</b><br/>
          ë²½ì²´ë¶€í”¼(ì¶”ì •) <b>${totalWallVolEst.toFixed(2)}ã¥</b><br/>
          <span style="color:#111;font-weight:900;">ì°½ ì¶”ê°€:</span> ê° ë²½ ì¹´ë“œì˜ <b>[+ ì°½]</b> (ê¸°ë³¸: ì¤‘ì•™ + sill 0.9m, x/sillì€ ì„ íƒ)<br/>
          <span style="color:#111;font-weight:900;">ì¤Œ:</span> <kbd>Ctrl</kbd>+íœ  (ë˜ëŠ” ìš°í•˜ë‹¨ +/âˆ’) Â· <span style="color:#111;font-weight:900;">ìº¡ì²˜:</span> <kbd>P</kbd>
        </div>
      `;
      elev.appendChild(header);

      const grid = document.createElement('div');
      grid.className = 'elevGrid';
      elev.appendChild(grid);

      globalData.forEach((r)=>{
        ensureRoomWindows(r);

        const color = EXCEL_COLORS[(r.id-1) % EXCEL_COLORS.length] || "#ddd";
        const winRectA = rectAreaSum(r);

        const placedTxt = (winRectA > 0)
          ? '<span class="ok">ì°½(ì‚¬ê°í˜•) ì…ë ¥ë¨</span>'
          : ((r.winTotal||0) > 0 ? '<span class="bad">ì°½ë©´ì ë§Œ ìˆìŒ(ê·¸ë¦¼ ì—†ìŒ)</span>' : '<span style="color:#6b7280;font-weight:900;">ì—†ìŒ</span>');

        const card = document.createElement('div');
        card.className = 'elevCard';

        card.innerHTML = `
          <div class="elevTitle">${r.name}</div>
          <div class="elevMeta">
            ì¹˜ìˆ˜: <b>${r.w}Ã—${r.d}Ã—${r.h}m</b> Â· ë²½ë‘ê»˜ <b>${(t*1000).toFixed(0)}mm</b><br/>
            ì°½ë©´ì (ì…ë ¥): <b>${(r.winTotal||0).toFixed(2)}ã¡</b> Â· ì°½(ì‚¬ê°í˜•): <b>${winRectA.toFixed(2)}ã¡</b> Â· ${placedTxt}
          </div>
        `;

        const walls = [
          { face:'front', label:'ì•', wallW:r.w, windows:(r.windows.front||[]) },
          { face:'back',  label:'ë’¤', wallW:r.w, windows:(r.windows.back||[]) },
          { face:'left',  label:'ì¢Œ', wallW:r.d, windows:(r.windows.left||[]) },
          { face:'right', label:'ìš°', wallW:r.d, windows:(r.windows.right||[]) },
        ];

        const row = document.createElement('div');
        row.className = 'wallRow';

        let anyInvalid = false;

        walls.forEach((winfo)=>{
          const { svg, invalid } = wallSVG(winfo.wallW, r.h, winfo.windows, color, `${winfo.label}ë©´`);
          anyInvalid = anyInvalid || invalid;

          const cnt = (winfo.windows||[]).length;

          const box = document.createElement('div');
          box.className = 'wallBox';
          box.innerHTML = `
            <div class="wallLabel">${winfo.label}ë©´ Â· í­ ${winfo.wallW}m Â· ë†’ì´ ${r.h}m</div>
            <div class="wallSvgWrap" data-action="winAdd" data-roomid="${r.id}" data-face="${winfo.face}" title="í´ë¦­í•´ì„œ ì°½ ì¶”ê°€">${svg}</div>
            <div style="margin-top:6px;font-size:12px;color:#666;display:flex;justify-content:space-between;gap:10px;align-items:center;">
              <span>ì°½(ì‚¬ê°í˜•) ${cnt}ê°œ</span>
              <span style="display:flex;gap:6px;">
                <button class="miniBtn primary" data-action="winAdd" data-roomid="${r.id}" data-face="${winfo.face}">+ ì°½</button>
                <button class="miniBtn danger" data-action="winClear" data-roomid="${r.id}" data-face="${winfo.face}">ì°½ ì§€ìš°ê¸°</button>
              </span>
            </div>
          `;
          row.appendChild(box);
        });

        card.appendChild(row);

        const note = document.createElement('div');
        const hasAnyWin = r.winPlaced;
        if (!hasAnyWin && (r.winTotal||0) > 0){
          note.className = 'note';
          note.textContent = 'â„¹ ì°½ë©´ì ì€ ì…ë ¥ëì§€ë§Œ, ì°½(ì‚¬ê°í˜•)ì€ ì•„ì§ ì—†ì–´ìš”. ì…ë©´ì—ì„œ [+ ì°½]ì„ ëˆŒëŸ¬ ì¶”ê°€í•˜ë©´ 3Dì—ë„ ë°˜ì˜ë©ë‹ˆë‹¤.';
        } else {
          note.className = anyInvalid ? 'warn' : 'good';
          note.textContent = anyInvalid
            ? 'âš  ì–´ë–¤ ì°½ì€ ë²½ ë°–ìœ¼ë¡œ ë‚˜ê°€ìš”. (ê°€ë¡œ/ì„¸ë¡œ ë˜ëŠ” x/sill í™•ì¸)'
            : 'âœ“ ì°½ ë°°ì¹˜ê°€ ì •ìƒ ë²”ìœ„ë¡œ ë³´ì…ë‹ˆë‹¤.';
        }
        card.appendChild(note);

        grid.appendChild(card);
      });
    }

    // -----------------------------
    // âœ… ì…ë©´ì—ì„œ ì°½ ì¶”ê°€/ì‚­ì œ (í”„ë¡¬í”„íŠ¸ ê¸°ë°˜)
    // -----------------------------
    function getRoomById(id){
      const rid = parseInt(id,10);
      return globalData.find(r => r.id === rid) || null;
    }
    function wallWidthForFace(room, face){
      if (face === 'front' || face === 'back') return room.w;
      return room.d;
    }
    function faceLabel(face){
      if (face==='front') return 'ì•';
      if (face==='back') return 'ë’¤';
      if (face==='left') return 'ì¢Œ';
      if (face==='right') return 'ìš°';
      return face;
    }

    function promptNumber(msg, defVal){
      const s = prompt(msg, (defVal===null || defVal===undefined) ? '' : String(defVal));
      if (s === null) return null;
      const n = parseFloat(numOnly(s));
      if (!isFinite(n) || n <= 0) return NaN;
      return n;
    }

    function addWindowWizard(room, face){
      ensureRoomWindows(room);

      const wallW = wallWidthForFace(room, face);
      const wallH = room.h;

      const defaultW = clamp(1.2, 0.3, wallW*0.9);
      const defaultH = clamp(1.2, 0.3, wallH*0.8);

      const ww0 = promptNumber(`[${room.name} / ${faceLabel(face)}ë©´]\nì°½ ê°€ë¡œ(m) ì…ë ¥`, defaultW.toFixed(2));
      if (ww0 === null) return;
      if (!isFinite(ww0) || ww0 <= 0){ alert('ê°€ë¡œ ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ìš”.'); return; }

      const wh0 = promptNumber(`[${room.name} / ${faceLabel(face)}ë©´]\nì°½ ì„¸ë¡œ(m) ì…ë ¥`, defaultH.toFixed(2));
      if (wh0 === null) return;
      if (!isFinite(wh0) || wh0 <= 0){ alert('ì„¸ë¡œ ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ìš”.'); return; }

      const ww = clamp(ww0, 0.2, wallW*0.98);
      const wh = clamp(wh0, 0.2, wallH*0.98);

      const xAsk = prompt(`[ì„ íƒ] ì™¼ìª½ ëì—ì„œ x(m)\në¹„ìš°ë©´ ìë™ ì •ì¤‘ì•™`, '');
      if (xAsk === null) return;
      let x = parseFloat(numOnly(xAsk));
      if (!isFinite(x)) x = (wallW - ww) / 2;
      x = clamp(x, 0, Math.max(0, wallW - ww));

      const sillAsk = prompt(`[ì„ íƒ] ì°½í„± sill(m)\në¹„ìš°ë©´ ê¸°ë³¸ 0.9m`, '');
      if (sillAsk === null) return;
      let sill = parseFloat(numOnly(sillAsk));
      if (!isFinite(sill)) sill = 0.9;
      sill = clamp(sill, 0, Math.max(0, wallH - wh));

      const existing = room.windows[face]?.length || 0;
      if (existing > 0){
        const rep = confirm(`[${room.name} / ${faceLabel(face)}ë©´]\nì´ë¯¸ ì°½ì´ ${existing}ê°œ ìˆì–´ìš”.\ní™•ì¸=êµì²´(ê¸°ì¡´ ì‚­ì œ), ì·¨ì†Œ=ì¶”ê°€(ê¸°ì¡´ ìœ ì§€)`);
        if (rep) room.windows[face] = [];
      }

      room.windows[face].push({ w: +ww.toFixed(3), h: +wh.toFixed(3), x: +x.toFixed(3), sill: +sill.toFixed(3) });
      ensureRoomWindows(room);

      // âœ… ì…ë ¥ ì°½ë©´ì ì´ 0ì´ë©´, ì‚¬ê°í˜• ë©´ì ìœ¼ë¡œ ìë™ ì±„ì›Œì¤Œ(ì´ˆë³´ìš©)
      if (!(room.winTotal > 0)){
        room.winTotal = rectAreaSum(room);
      }

      buildElevation();
    }

    function clearWindowsOnFace(room, face){
      ensureRoomWindows(room);
      const cnt = room.windows[face]?.length || 0;
      if (!cnt){ alert('ì§€ìš¸ ì°½ì´ ì—†ì–´ìš”.'); return; }
      if (!confirm(`[${room.name} / ${faceLabel(face)}ë©´] ì°½ ${cnt}ê°œë¥¼ ì§€ìš¸ê¹Œìš”?`)) return;
      room.windows[face] = [];
      ensureRoomWindows(room);
      buildElevation();
    }

    elev.addEventListener('click', (e)=>{
      const t = e.target.closest('[data-action]');
      if (!t) return;
      const action = t.dataset.action;
      const roomId = t.dataset.roomid;
      const face = t.dataset.face;
      const room = getRoomById(roomId);
      if (!room) return;

      if (action === 'winAdd'){
        addWindowWizard(room, face);
      }
      if (action === 'winClear'){
        clearWindowsOnFace(room, face);
      }
    });

    // -----------------------------
    // 5) 3D
    // -----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf2f2f2);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(12, 12, 16);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    threeEl.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.75));
    const dir = new THREE.DirectionalLight(0xffffff, 0.85);
    dir.position.set(50, 80, 50);
    dir.castShadow = true;
    scene.add(dir);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.GridHelper(100,100,0xbbbbbb,0xeeeeee));

    let pieces = [], ghosts = [], hitMeshes = [], labels3D = [];
    let labelsVisible = true, ghostsVisible = true;
    let shiftDown = false;

    const raycaster = new THREE.Raycaster();
    const dragPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
    const dragOffset = new THREE.Vector3();
    let dragging = false;
    let draggedGroup = null;

    function makeLabelSprite(text1, text2){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = 'bold 40px Malgun Gothic';
      const w = ctx.measureText(text1).width + 70;
      canvas.width = Math.max(220, w);
      canvas.height = 120;
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 5;
      ctx.strokeRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#111';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 38px Malgun Gothic';
      ctx.fillText(text1, canvas.width/2, 42);
      ctx.font = '26px Malgun Gothic';
      ctx.fillText(text2, canvas.width/2, 86);

      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true }));
      sprite.scale.set(canvas.width/20, 6, 1);
      return sprite;
    }

    function addWindowRectOnFace(group, face, roomW, roomD, roomH, win){
      const wallW = (face==='front' || face==='back') ? roomW : roomD;

      const ww = parseFloat(win.w)||0;
      const wh = parseFloat(win.h)||0;
      let x = parseFloat(win.x);
      let sill = parseFloat(win.sill);

      if (!isFinite(x)) x = (wallW - ww) / 2;
      if (!isFinite(sill)) sill = 0.9;

      const chk = validateWindowRect(wallW, roomH, {w:ww,h:wh,x,sill});
      const invalid = !chk.ok;

      const mat = new THREE.MeshBasicMaterial({
        color: invalid ? 0xff4d4d : 0x66ccff,
        transparent: true,
        opacity: invalid ? 0.45 : 0.32,
        side: THREE.DoubleSide
      });

      const geo = new THREE.PlaneGeometry(ww, wh);
      const mesh = new THREE.Mesh(geo, mat);
      const eps = 0.002;

      const y = sill + wh/2;

      if (face === 'front'){
        const cx = (-roomW/2) + x + ww/2;
        mesh.position.set(cx, y, -(roomD/2) + eps);
        mesh.rotation.y = 0;
      } else if (face === 'back'){
        const cx = (-roomW/2) + x + ww/2;
        mesh.position.set(cx, y, (roomD/2) - eps);
        mesh.rotation.y = Math.PI;
      } else if (face === 'left'){
        const cz = (-roomD/2) + x + ww/2;
        mesh.position.set(-(roomW/2) + eps, y, cz);
        mesh.rotation.y = -Math.PI/2;
      } else if (face === 'right'){
        const cz = (-roomD/2) + x + ww/2;
        mesh.position.set((roomW/2) - eps, y, cz);
        mesh.rotation.y = Math.PI/2;
      }

      group.add(mesh);

      const edge = new THREE.LineSegments(
        new THREE.EdgesGeometry(geo),
        new THREE.LineBasicMaterial({ color: invalid ? 0x7f0000 : 0x0b4aa2 })
      );
      edge.position.copy(mesh.position);
      edge.rotation.copy(mesh.rotation);
      group.add(edge);

      return invalid;
    }

    function create3DRoom(d, colorHex, wallT){
      ensureRoomWindows(d);

      const group = new THREE.Group();
      const w = d.w, depth = d.d, h = d.h;
      const t = wallT;

      const matColor = new THREE.Color(colorHex);

      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(w, depth),
        new THREE.MeshStandardMaterial({ color: matColor, side: THREE.DoubleSide })
      );
      floor.rotation.x = -Math.PI/2;
      floor.position.y = 0.01;
      floor.receiveShadow = true;
      group.add(floor);

      const wallMat = new THREE.MeshStandardMaterial({ color: matColor, roughness:0.75, transparent:true, opacity:0.88 });

      const front = new THREE.Mesh(new THREE.BoxGeometry(w + 2*t, h, t), wallMat);
      front.position.set(0, h/2, -(depth/2 + t/2));
      group.add(front);

      const back = front.clone();
      back.position.set(0, h/2, +(depth/2 + t/2));
      group.add(back);

      const side = new THREE.Mesh(new THREE.BoxGeometry(t, h, depth + 2*t), wallMat);
      side.position.set(-(w/2 + t/2), h/2, 0);
      group.add(side);

      const side2 = side.clone();
      side2.position.set(+(w/2 + t/2), h/2, 0);
      group.add(side2);

      // âœ… ì°½(ì‚¬ê°í˜•): ì‹¤ì œ ì°½ë§Œ í‘œì‹œ
      let anyInvalid = false;
      for (const face of ['front','back','left','right']){
        for (const win of (d.windows?.[face] || [])){
          anyInvalid = addWindowRectOnFace(group, face, w, depth, h, win) || anyInvalid;
        }
      }

      const label = makeLabelSprite(d.name, `(${d.w}Ã—${d.d}Ã—${d.h}m)`);
      label.position.set(0, h + 2.2, 0);
      label.visible = labelsVisible;
      group.add(label);
      labels3D.push(label);

      const hit = new THREE.Mesh(
        new THREE.PlaneGeometry(w, depth),
        new THREE.MeshBasicMaterial({ visible:false })
      );
      hit.rotation.x = -Math.PI/2;
      hit.position.y = 0.12;
      hit.userData.parentGroup = group;
      group.add(hit);
      hitMeshes.push(hit);

      const winAInput = d.winTotal || 0;
      const winARects = rectAreaSum(d);

      const floorNet = w * depth;
      const floorGrossEst = (w + 2*t) * (depth + 2*t);
      const periInner = (w + depth) * 2;
      const periOuter = ((w + 2*t) + (depth + 2*t)) * 2;
      const wallAreaInner = periInner * h;
      const wallAreaOuter = periOuter * h;
      const wallNetInner = Math.max(0, wallAreaInner - winAInput);
      const wallVolEst = periOuter * t * h;

      group.userData = {
        id: d.id,
        name: d.name,
        w, d: depth, h,
        wallT: t,
        winTotal: winAInput,
        winRectsArea: winARects,
        winPlaced: d.winPlaced,
        windowInvalid: anyInvalid,
        metrics: {
          floorNet, floorGrossEst,
          periInner, periOuter,
          wallAreaInner, wallAreaOuter,
          wallNetInner,
          wallVolEst
        },
        targetPos: new THREE.Vector3(),
      };

      return group;
    }

    function build3D(){
      pieces.forEach(p => scene.remove(p));
      ghosts.forEach(g => scene.remove(g));
      pieces = []; ghosts = []; hitMeshes = []; labels3D = [];
      tooltip.style.display = 'none';

      const t = globalWallThicknessM;

      let x=0, z=0, rowH=0;
      const LIMIT = 25;

      globalData.forEach(d=>{
        ensureRoomWindows(d);

        const color = EXCEL_COLORS[(d.id-1) % EXCEL_COLORS.length] || "#ccc";
        const g = create3DRoom(d, color, t);

        if (x + d.w > LIMIT){ x=0; z += rowH + 0.6; rowH=0; }

        g.userData.targetPos.set(x + d.w/2, 0, z + d.d/2);
        x += d.w + 0.6;
        rowH = Math.max(rowH, d.d);

        const ghost = new THREE.Mesh(
          new THREE.PlaneGeometry(d.w, d.d),
          new THREE.MeshBasicMaterial({ color:0x111111, transparent:true, opacity:0.14, side:THREE.DoubleSide })
        );
        ghost.rotation.x = -Math.PI/2;
        ghost.position.copy(g.userData.targetPos);
        ghost.position.y = 0.005;
        ghost.visible = ghostsVisible;
        scene.add(ghost);
        ghosts.push(ghost);

        g.position.set(g.userData.targetPos.x + (Math.random()-0.5)*15, 0, g.userData.targetPos.z + 8 + Math.random()*8);
        scene.add(g);
        pieces.push(g);
      });
    }

    // -----------------------------
    // 6) ëª¨ë“œ ìŠ¤ìœ„ì¹˜
    // -----------------------------
    function switchMode(next){
      if (mode === '2d') save2DPositions();
      mode = next;

      $('mode2d').classList.toggle('active', mode==='2d');
      $('mode3d').classList.toggle('active', mode==='3d');
      $('modeElev').classList.toggle('active', mode==='elev');

      twod.style.display = (mode==='2d') ? 'block' : 'none';
      threeEl.style.display = (mode==='3d') ? 'block' : 'none';
      elev.style.display = (mode==='elev') ? 'block' : 'none';
      tooltip.style.display = 'none';

      if (mode === 'elev') setUiCollapsed(true);

      syncZoomHud();
      if (mode === '2d') setZoomForMode(twodZoom);
      if (mode === 'elev') setZoomForMode(elevZoom);

      if (globalData.length){
        if (mode==='2d') build2D();
        else if (mode==='3d') build3D();
        else buildElevation();
      }

      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    }

    $('mode2d').addEventListener('click', ()=>switchMode('2d'));
    $('mode3d').addEventListener('click', ()=>switchMode('3d'));
    $('modeElev').addEventListener('click', ()=>switchMode('elev'));

    // -----------------------------
    // 7) ë²„íŠ¼ë“¤
    // -----------------------------
    $('resetBtn').addEventListener('click', ()=>{
      if (confirm('ì´ˆê¸°í™”í• ê¹Œìš”? (ì…ë ¥/ë„í˜• ëª¨ë‘ ì‚­ì œ)')){
        hardReset({ clearInput:true });
        setDefaultStatus();
      }
    });

    $('clearInputBtn').addEventListener('click', ()=>{ inputEl.value=''; });

    $('sampleBtn').addEventListener('click', ()=>{
      inputEl.value =
`ê³µê°„ID\tê³µê°„ëª…\tê°€ë¡œ(m)\tì„¸ë¡œ(m)\të²½ë†’ì´(m)\tì°½ë©´ì (ã¡)
1\tê±°ì‹¤\t5.3\t2.4\t2.3\t3.2
2\të°©1\t2.4\t2.4\t2.3\t0
3\të°©2\t3.8\t5.45\t2.3\t1.5
4\të³µë„1\t1.55\t5.55\t2.3\t0
5\të°©3\t2.45\t5.55\t2.3\t2.0`;
      setStatus(`<b>ìƒíƒœ</b><br/>ìƒ˜í”Œ ì…ë ¥ ì™„ë£Œ. ì´ì œ <b>[ë„ë©´ ìƒì„±]</b>ì„ ëˆŒëŸ¬ë³´ì„¸ìš”. (ì°½ ê·¸ë¦¼ì€ ì…ë©´ì—ì„œ [+ ì°½])`);
    });

    $('pasteBtn').addEventListener('click', async ()=>{
      try{
        const t = await navigator.clipboard.readText();
        if (!t) { alert('í´ë¦½ë³´ë“œì— í…ìŠ¤íŠ¸ê°€ ì—†ì–´ìš”.'); return; }
        inputEl.value = t;
        setStatus(`<b>ìƒíƒœ</b><br/><span class="ok">í´ë¦½ë³´ë“œ ë‚´ìš© ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!</span> ì´ì œ <b>[ë„ë©´ ìƒì„±]</b> ëˆ„ë¥´ì„¸ìš”.`);
      }catch(e){
        alert('í´ë¦½ë³´ë“œ ì ‘ê·¼ì´ ì°¨ë‹¨ëì–´ìš”. ì§ì ‘ ë¶™ì—¬ë„£ê¸°(Ctrl+V)ë¡œ í•´ì£¼ì„¸ìš”.');
      }
    });

    $('buildBtn').addEventListener('click', ()=>{
      const t = getGlobalThickness();
      const { parsed, skipped } = parseText(inputEl.value || '');
      if (!parsed.length){
        setStatus(`<b>ìƒíƒœ</b><br/><span class="bad">ì¸ì‹ëœ ë°©ì´ 0ê°œ</span>ì…ë‹ˆë‹¤. ë°©ì´ë¦„/ê°€ë¡œ/ì„¸ë¡œ ë˜ëŠ” í‘œ í†µì§¸ë¡œ ë¶™ì—¬ë„£ê³  ë‹¤ì‹œ ëˆŒëŸ¬ì£¼ì„¸ìš”.`);
        return;
      }

      let nextId = 1;
      parsed.forEach(r=>{
        if (!r.id || r.id <= 0) r.id = nextId;
        nextId = Math.max(nextId, r.id + 1);
        ensureRoomWindows(r);
      });

      globalData = parsed;

      const totalFloorNet = globalData.reduce((s,r)=>s + (r.w*r.d), 0);
      const totalFloorGrossEst = globalData.reduce((s,r)=>s + ((r.w+2*t)*(r.d+2*t)), 0);
      const totalWallInner = globalData.reduce((s,r)=>s + ((r.w+r.d)*2*r.h), 0);
      const totalWallOuter = globalData.reduce((s,r)=>s + (((r.w+2*t)+(r.d+2*t))*2*r.h), 0);
      const totalWinInput = globalData.reduce((s,r)=>s + (r.winTotal||0), 0);
      const totalWinRects = globalData.reduce((s,r)=>s + rectAreaSum(r), 0);
      const totalWallNetInner = Math.max(0, totalWallInner - totalWinInput);
      const totalWallVolEst = globalData.reduce((s,r)=>{
        const periOuter = ((r.w+2*t)+(r.d+2*t))*2;
        return s + (periOuter * t * r.h);
      }, 0);

      const winInputCnt = globalData.filter(r => (r.winTotal||0) > 0).length;
      const winRectCnt  = globalData.filter(r => rectAreaSum(r) > 0).length;

      setStatus(
        `<b>ìƒíƒœ</b><br/>
         ë²½ë‘ê»˜: <b>${(t*1000).toFixed(0)}mm</b><br/>
         ë°© <b>${globalData.length}</b>ê°œ ì¸ì‹ / ê±´ë„ˆëœ€ <b>${skipped}</b>ì¤„<br/>
         ìˆœë©´ì (ì—‘ì…€ ë™ì¼): <b>${totalFloorNet.toFixed(2)}ã¡</b><br/>
         ë²½ í¬í•¨ ì¶”ì •(ì°¸ê³ ): <b>${totalFloorGrossEst.toFixed(2)}ã¡</b><br/>
         ë²½ë©´ì (ë‚´ì¸¡): <b>${totalWallInner.toFixed(2)}ã¡</b> / ì°½ë©´ì (ì…ë ¥): <b>${totalWinInput.toFixed(2)}ã¡</b> / ì‹œê³µë©´ì (ë‚´ì¸¡-ì°½): <b>${totalWallNetInner.toFixed(2)}ã¡</b><br/>
         ì°½(ì‚¬ê°í˜•,í‘œì‹œ): <b>${totalWinRects.toFixed(2)}ã¡</b><br/>
         ë²½ë©´ì (ì™¸ì¸¡ ì¶”ì •): <b>${totalWallOuter.toFixed(2)}ã¡</b> / ë²½ì²´ë¶€í”¼(ì¶”ì •): <b>${totalWallVolEst.toFixed(2)}ã¥</b><br/>
         <span class="hint">ì°½ë©´ì  ì…ë ¥ ë°© ${winInputCnt}ê°œ Â· ì°½(ì‚¬ê°í˜•) ì…ë ¥ ë°© ${winRectCnt}ê°œ (ì…ë©´ì—ì„œ [+ ì°½])</span>`
      );

      if (mode==='2d') build2D();
      else if (mode==='3d') build3D();
      else buildElevation();
    });

    // JSON ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°
    $('jsonSaveBtn').addEventListener('click', ()=>{
      const t = getGlobalThickness();
      if (!globalData.length){
        const { parsed } = parseText(inputEl.value || '');
        if (!parsed.length){ alert('ì €ì¥í•  ë°ì´í„°ê°€ ì—†ì–´ìš”. ë¨¼ì € ë¶™ì—¬ë„£ê³  ë„ë©´ ìƒì„±í•˜ì„¸ìš”.'); return; }
        globalData = parsed.map(r=>ensureRoomWindows(r));
      }

      const payload = {
        app: "yugy.site",
        name: "ëš±ëšœë£¨ ë„ë©´ì†Œìƒìˆ  ë°©ëª©ë¡",
        version: "2.41",
        savedAt: new Date().toISOString(),
        wallThicknessMm: Math.round(t*1000),
        rooms: globalData
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type:"application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ddungdduru_rooms.json';
      a.click();
      URL.revokeObjectURL(url);
      alert('JSON ì €ì¥ ì™„ë£Œ! (ë‹¤ìš´ë¡œë“œ í´ë” í™•ì¸)');
    });

    $('jsonLoadBtn').addEventListener('click', ()=> $('jsonFile').click());
    $('jsonFile').addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      if (!f) return;
      try{
        const text = await f.text();
        const obj = JSON.parse(text);
        const rooms = obj.rooms || obj.data || [];
        if (!Array.isArray(rooms) || !rooms.length) throw new Error('rooms ì—†ìŒ');

        const wt = obj.wallThicknessMm;
        if (isFinite(wt) && wt > 0){
          $('wallThk').value = String(wt);
        }
        getGlobalThickness();

        // roomsë¥¼ ì§ì ‘ ë¡œë“œ(ì°½ ì‚¬ê°í˜• í¬í•¨)
        globalData = rooms.map((r,i)=>{
          const rr = {
            id: r.id ?? (i+1),
            name: r.name ?? '',
            w: r.w ?? 0,
            d: r.d ?? r.depth ?? 0,
            h: r.h ?? 2.3,
            winTotal: r.winTotal ?? r.winArea ?? 0,
            winAreaPlaced: r.winAreaPlaced ?? false,
            win: r.win ?? {front:0,back:0,left:0,right:0},
            windows: r.windows ?? makeEmptyWindows(),
            winPlaced: false,
            x2d: r.x2d,
            y2d: r.y2d
          };
          return ensureRoomWindows(rr);
        });

        // ì…ë ¥ì°½ì—ëŠ” 'ê³„ì‚°ìš©' í‘œ í˜•íƒœë¡œë§Œ ë³µì›(ì°½ ì‚¬ê°í˜•ì€ JSONì— ìœ ì§€)
        const lines = [];
        lines.push("ê³µê°„ID\tê³µê°„ëª…\tê°€ë¡œ(m)\tì„¸ë¡œ(m)\të²½ë†’ì´(m)\tì°½ë©´ì (ã¡)");
        globalData.forEach((r)=>{
          lines.push(`${r.id}\t${r.name}\t${r.w}\t${r.d}\t${r.h}\t${r.winTotal||0}`);
        });
        inputEl.value = lines.join('\n');

        if (mode==='2d') build2D();
        else if (mode==='3d') build3D();
        else buildElevation();

        setStatus(`<b>ìƒíƒœ</b><br/><span class="ok">JSON ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!</span> ë°© ${globalData.length}ê°œ. (ì°½ ì‚¬ê°í˜• í¬í•¨)`);
      }catch(err){
        alert('JSON í˜•ì‹ì´ ë§ì§€ ì•Šì•„ìš”. (ì´ ì‚¬ì´íŠ¸ì—ì„œ ì €ì¥í•œ JSONì„ ì˜¬ë ¤ì£¼ì„¸ìš”)');
      }finally{
        e.target.value = '';
      }
    });

    // -----------------------------
    // 8) 3D ì¸í„°ë™ì…˜/íˆ´íŒ/ë“œë˜ê·¸
    // -----------------------------
    function getMouse(e){
      const rect = renderer.domElement.getBoundingClientRect();
      return {
        x: ((e.clientX - rect.left)/rect.width) * 2 - 1,
        y: -(((e.clientY - rect.top)/rect.height) * 2 - 1)
      };
    }

    threeEl.addEventListener('pointerdown', (e)=>{
      if (mode!=='3d' || !shiftDown) return;
      const m = getMouse(e);
      raycaster.setFromCamera(m, camera);
      const hits = raycaster.intersectObjects(hitMeshes);
      if (hits.length){
        dragging = true;
        draggedGroup = hits[0].object.userData.parentGroup;
        controls.enabled = false;
        tooltip.style.display = 'none';
        renderer.domElement.style.cursor = 'grabbing';
        raycaster.ray.intersectPlane(dragPlane, dragOffset);
        dragOffset.sub(draggedGroup.position);
      }
    });

    threeEl.addEventListener('pointermove', (e)=>{
      if (mode!=='3d') return;

      const m = getMouse(e);
      raycaster.setFromCamera(m, camera);

      if (dragging && draggedGroup){
        const p = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, p);
        draggedGroup.position.copy(p.sub(dragOffset));
        return;
      }

      const hits = raycaster.intersectObjects(hitMeshes);
      if (shiftDown && hits.length) renderer.domElement.style.cursor = 'grab';
      else renderer.domElement.style.cursor = 'auto';

      if (hits.length){
        const u = hits[0].object.userData.parentGroup.userData;

        const winTxt = (u.winRectsArea||0) > 0 ? 'ì…ë ¥ë¨' : 'ì—†ìŒ';

        tooltip.innerHTML =
          `<b>${u.name}</b>
           <div class="ttRow"><span class="ttLbl">ì¹˜ìˆ˜</span><span class="ttVal">${u.w}Ã—${u.d}Ã—${u.h} m</span></div>
           <div class="ttRow"><span class="ttLbl">ë²½ë‘ê»˜</span><span class="ttVal">${(u.wallT*1000).toFixed(0)} mm</span></div>
           <div class="ttRow"><span class="ttLbl">ë°”ë‹¥(ìˆœ)</span><span class="ttVal">${u.metrics.floorNet.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ë°”ë‹¥(ë²½í¬í•¨ ì¶”ì •)</span><span class="ttVal">${u.metrics.floorGrossEst.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ë²½ë©´ì (ë‚´ì¸¡)</span><span class="ttVal">${u.metrics.wallAreaInner.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ì°½ë©´ì (ì…ë ¥)</span><span class="ttVal">${(u.winTotal||0).toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ì°½(ì‚¬ê°í˜•)</span><span class="ttVal">${(u.winRectsArea||0).toFixed(2)} ã¡ (${winTxt})</span></div>
           <div class="ttRow"><span class="ttLbl">ì‹œê³µë©´ì (ë‚´ì¸¡-ì°½)</span><span class="ttVal">${u.metrics.wallNetInner.toFixed(2)} ã¡</span></div>
           <div class="ttRow"><span class="ttLbl">ë²½ì²´ë¶€í”¼(ì¶”ì •)</span><span class="ttVal">${u.metrics.wallVolEst.toFixed(2)} ã¥</span></div>
          `;
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 14) + 'px';
        tooltip.style.top  = (e.clientY + 14) + 'px';
      }else{
        tooltip.style.display = 'none';
      }
    });

    function endDrag(){
      if (dragging && draggedGroup){
        const t = draggedGroup.userData.targetPos;
        if (draggedGroup.position.distanceTo(t) < 0.5) draggedGroup.position.copy(t);
      }
      dragging = false;
      draggedGroup = null;
      controls.enabled = true;
      renderer.domElement.style.cursor = shiftDown ? 'grab' : 'auto';
    }
    threeEl.addEventListener('pointerup', endDrag);
    threeEl.addEventListener('pointerleave', endDrag);

    // -----------------------------
    // 9) ë‹¨ì¶•í‚¤: P ìº¡ì²˜ + ì¤Œ ë³´ì¡°
    // -----------------------------
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if (k==='shift') shiftDown = true;

      if (mode==='2d' || mode==='elev'){
        if (k==='+' || k==='=' ) setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 1.12);
        if (k==='-' || k==='_' ) setZoomForMode((mode==='2d'?twodZoom:elevZoom) * 0.90);
        if (k==='0') setZoomForMode(1);
      }

      if (k==='p'){
        if (mode==='2d'){
          html2canvas(twod).then((c)=>{
            const a = document.createElement('a');
            a.download = '2D_Plan.png';
            a.href = c.toDataURL('image/png');
            a.click();
          });
        } else if (mode==='elev'){
          html2canvas(elev).then((c)=>{
            const a = document.createElement('a');
            a.download = 'Elevation.png';
            a.href = c.toDataURL('image/png');
            a.click();
          });
        } else {
          renderer.render(scene, camera);
          const a = document.createElement('a');
          a.download = '3D_View.png';
          a.href = renderer.domElement.toDataURL('image/png');
          a.click();
        }
      }

      if (mode==='3d'){
        if (k==='g'){ ghostsVisible = !ghostsVisible; ghosts.forEach(x=>x.visible=ghostsVisible); }
        if (k==='l'){ labelsVisible = !labelsVisible; labels3D.forEach(x=>x.visible=labelsVisible); }
      }
    });
    window.addEventListener('keyup', (e)=>{
      if (e.key === 'Shift'){
        shiftDown = false;
        renderer.domElement.style.cursor = 'auto';
      }
    });

    // -----------------------------
    // 10) ë¦¬ì‚¬ì´ì¦ˆ/ì• ë‹ˆë©”ì´ì…˜
    // -----------------------------
    window.addEventListener('resize', ()=>{
      calcUiHide();
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (mode==='2d') build2D();
      if (mode==='elev') buildElevation();
    });

    function animate(){
      requestAnimationFrame(animate);
      if (mode==='3d'){
        controls.update();
        renderer.render(scene, camera);
      }
    }
    animate();

    // ì‹œì‘
    calcUiHide();
    applyUiCollapsed();
    getGlobalThickness();
    setDefaultStatus();

    attachWheelZoom(twod, '2d');
    attachWheelZoom(elev, 'elev');
    attachPinchZoom(twod, ()=>twodZoom, (z)=>{ if(mode!=='2d') return; setZoomForMode(z); });
    attachPinchZoom(elev, ()=>elevZoom, (z)=>{ if(mode!=='elev') return; setZoomForMode(z); });

    switchMode('3d');
    maybeAutoClearOnReload();
  </script>
</body>
</html>
